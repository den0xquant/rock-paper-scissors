<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Rock Paper Scissors ‚Äî Vanilla</title>
    <style>
        :root {
            --bg: #f5f7fb;
            --card: #ffffff;
            --muted: #6b7280;
            --border: #e5e7eb;
            --text: #0f172a;
            --accent: #2563eb;
            --accent2: #7c3aed;
            --win: #16a34a;
            --lose: #dc2626;
            --tie: #ca8a04;
            --shadow: 0 8px 30px rgba(2, 8, 23, .06);
            --radius: 16px;
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%
        }

        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Inter, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            background: var(--bg);
            color: var(--text);
        }

        .wrap {
            min-height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
        }

        .card {
            width: 100%;
            max-width: 720px;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 24px;
        }

        h1 {
            margin: 0 0 8px;
            font-size: 32px;
            line-height: 1.2;
            text-align: center;
            font-weight: 800;
            letter-spacing: -0.02em;
        }

        .sub {
            text-align: center;
            color: var(--muted);
            margin-bottom: 20px;
        }

        .scoreboard {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            padding: 16px;
            background: #f8fafc;
            border: 1px solid var(--border);
            border-radius: 12px;
            margin-bottom: 20px;
        }

        .score {
            flex: 1;
            text-align: center;
        }

        .label {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: var(--accent);
        }

        .label.cpu {
            color: var(--accent2);
        }

        .score b {
            display: block;
            font-size: 32px;
            margin-top: 6px;
        }

        .vs {
            width: 72px;
            text-align: center;
            font-weight: 800;
            color: #9aa0a6;
        }

        .result {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            margin-bottom: 20px;
        }

        .hidden {
            display: none !important;
        }

        .prompt {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--muted);
            opacity: 0;
            animation: fadeIn .35s ease forwards;
        }

        .prompt-emoji {
            font-size: 20px;
        }

        .battle {
            width: 100%;
            opacity: 0;
            animation: fadeInUp .35s ease forwards;
        }

        .battle-row {
            display: flex;
            align-items: center;
            justify-content: space-around;
            font-size: 48px;
        }

        .vs-text {
            font-size: 18px;
            color: #9aa0a6;
        }

        .emoji {
            display: inline-block;
            will-change: transform;
        }

        .result-text {
            margin-top: 10px;
            font-weight: 800;
            font-size: 20px;
        }

        .result-text.win {
            color: var(--win);
        }

        .result-text.lose {
            color: var(--lose);
        }

        .result-text.tie {
            color: var(--tie);
        }

        .controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .btn {
            width: 96px;
            height: 96px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: #fff;
            font-size: 40px;
            line-height: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: var(--shadow);
            transition: transform .12s ease, box-shadow .12s ease, opacity .12s ease;
        }

        .btn:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 10px 34px rgba(2, 8, 23, .10);
        }

        .btn:active {
            transform: translateY(0) scale(.98);
        }

        .btn:disabled {
            opacity: .45;
            cursor: not-allowed;
            transform: none;
        }

        .reset {
            text-align: center;
        }

        .reset-btn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: #fff;
            cursor: pointer;
            transition: background .12s ease, transform .12s ease;
        }

        .reset-btn:hover {
            background: #f8fafc;
            transform: translateY(-1px);
        }

        .reset-btn:active {
            transform: translateY(0);
        }

        .reset-icon {
            font-size: 16px
        }

        @keyframes wobble {
            0% {
                transform: rotate(0)
            }

            20% {
                transform: rotate(-10deg)
            }

            50% {
                transform: rotate(10deg)
            }

            100% {
                transform: rotate(0)
            }
        }

        .wobble {
            animation: wobble .5s ease;
        }

        @keyframes fadeIn {
            to {
                opacity: 1
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(8px)
            }

            to {
                opacity: 1;
                transform: translateY(0)
            }
        }

        @media (max-width:560px) {
            .battle-row {
                font-size: 40px
            }

            .btn {
                width: 84px;
                height: 84px;
                font-size: 36px
            }
        }

        #duel {
            display: block;
            justify-content: space-around;
        }
    </style>
</head>

<body>
    <div class="wrap">
        <main class="card" aria-live="polite">
            <header>
                <h1>Rock Paper Scissors</h1>
                <div class="sub" id="resultBanner"></div>
                <div class="sub">
                    <span class="pill" title="Round">Round <b id="roundNo">1</b></span>
                </div>
            </header>

            <section class="scoreboard" aria-label="Scoreboard">
                <div class="score">
                    <div class="label">
                        <span aria-hidden="true">üë§</span>
                        <span id="pidPill"></span>
                    </div>
                    <b id="youScore">0</b>
                </div>
                <div class="vs">VS</div>
                <div class="score">
                    <div class="label cpu">
                        <span aria-hidden="true">üë§</span>
                        <span id="oppPill"></span>
                    </div>
                    <b id="oppScore">0</b>
                </div>
            </section>

            <section class="result">
                <div id="prompt" class="prompt">
                    <span id="message"></span>
                </div>
            </section>

            <section id="duel" class="controls hidden">
                <div class="battle-row">
                    <div class="side you">
                        <div id="youIcon" class="btn" aria-label="Your icon"></div>
                    </div>

                    <div class="vs-text">vs</div>

                    <div class="side opp">
                        <div id="oppSpin" class="btn" title="Waiting">‚è≥</div>
                        <div id="oppIcon" class="btn" aria-label="Opponent icon"></div>
                    </div>
                </div>

                <div id="resultText" class="result-text"></div>
            </section>

            <section class="controls" id="moves" aria-label="Controls">
                <button class="btn" data-move="r" aria-label="Rock">ü™®</button>
                <button class="btn" data-move="p" aria-label="Paper">üìÑ</button>
                <button class="btn" data-move="s" aria-label="Scissors">‚úÇÔ∏è</button>
            </section>
        </main>
    </div>


    <script>
        // ====== Config
        const RESULT_GRACE_MS = 2300; // —Å–∫–æ–ª—å–∫–æ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –±–∞–Ω–Ω–µ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ state
        const ICON = { rock: 'ü™®', paper: 'üìÑ', scissors: '‚úÇÔ∏è' };
        const MOVES = { r: 'rock', p: 'paper', s: 'scissors' };

        // ====== DOM
        const el = {
            banner: document.getElementById('resultBanner'),
            message: document.getElementById('message'),
            youPid: document.getElementById('pidPill'),
            oppPid: document.getElementById('oppPill'),
            roundNo: document.getElementById('roundNo'),
            youScore: document.getElementById('youScore'),
            oppScore: document.getElementById('oppScore'),
            youIcon: document.getElementById('youIcon'),
            oppSpin: document.getElementById('oppSpin'),
            oppIcon: document.getElementById('oppIcon'),
            moves: document.getElementById('moves'),
            duel: document.getElementById('duel'),
            duelYou: document.getElementById('duelYou'),
            duelOpp: document.getElementById('duelOpp'),
            rematch: document.getElementById('rematch'),
        };

        // ====== URL / Identity
        const params = new URLSearchParams(location.search);
        const ROOM = params.get('room') || 'demo';
        let PID = params.get('pid') || localStorage.getItem('rps_pid') || ('u' + Math.random().toString(16).slice(2, 8));
        localStorage.setItem('rps_pid', PID);
        // el.room.textContent = `room: ${ROOM}`;
        el.youPid.textContent = `${PID}`;

        // ====== State
        const state = {
            ws: null,
            canMove: false,
            lastResult: null,
            resultLockUntil: 0,
            deferred: null, // –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã–π WAITING_MOVE / MATCH_OVER
            snapshot: null,
        };

        // ====== Helpers
        const now = () => Date.now();
        function wsURL() {
            const proto = location.protocol === 'https:' ? 'wss' : 'ws';
            return `${proto}://${location.host}/ws/rooms/${encodeURIComponent(ROOM)}?pid=${encodeURIComponent(PID)}`;
        }
        function setBanner(kind, text) {
            el.banner.className = 'banner ' + (kind || '');
            el.banner.textContent = text || '';
            el.banner.style.display = text ? 'grid' : 'none';
        }
        function setMoves(on) {
            el.duel.style.display = on ? 'block' : 'none';
            el.moves.style.display = on ? 'flex' : 'none';
            document.querySelectorAll('[data-move]').forEach(b => b.disabled = !on);
        }
        function setOppSpinner(on) {
            el.oppSpin.style.display = on ? 'inline-flex' : 'none';
            el.oppIcon.style.display = on ? 'none' : 'inline-flex';
        }
        function stars(container, have) {
            container.textContent = have;
        }
        function updateFromSnapshot(s) {
            state.snapshot = s;
            // el.state.textContent = `state: ${s.state}`;
            // el.wins.textContent = s.wins_needed ?? state.winsNeeded;
            // state.winsNeeded = s.wins_needed ?? state.winsNeeded;
            el.roundNo.textContent = String(s.round_id ?? 0);

            // map players
            const me = s.players.find(p => p.pid === PID) || { score: 0, last_move: '' };
            const opp = s.players.find(p => p.pid !== PID) || { score: 0, last_move: '' };

            stars(el.youScore, me.score ?? 0);
            stars(el.oppScore, opp.score ?? 0);

            // el.youIcon.textContent = me.last_move ? ICON[me.last_move] : '‚Äî';
            // if (opp.last_move) {
            //     setOppSpinner(false);
            //     el.oppIcon.textContent = ICON[opp.last_move];
            // } else {
            //     setOppSpinner(true);
            //     el.oppIcon.textContent = '‚Äî';
            // }
        }

        // ====== Renderers
        function onJoined() { el.message.textContent = 'Waiting for opponent‚Ä¶'; setMoves(false); setBanner('', ''); el.duel.style.display = 'none'; }
        function onWaitingOpp() { el.message.textContent = 'Waiting for opponent‚Ä¶'; setMoves(false); setBanner('', ''); el.duel.style.display = 'block'; }
        function onWaitingMove() {
            if (now() < state.resultLockUntil) { state.deferred = { type: 'WAITING_MOVE' }; return; }
            el.message.textContent = 'Make your pick'; setMoves(true); setBanner('', ''); el.duel.style.display = 'none';
            setOppSpinner(true);
            el.oppPid.textContent = state?.snapshot?.players?.find(p => p.pid !== PID)?.pid ?? '';
            // el.youHint.textContent = 'Take your pick';
            // el.oppHint.textContent = 'Waiting for the opponent';
        }
        function onAck() {
            setMoves(false);
            setOppSpinner(true);
            // el.oppHint.textContent = 'Opponent is thinking‚Ä¶';
            el.duel.style.display = 'block';
        }
        function onResult(payload) {
            state.lastResult = payload;
            setOppSpinner(false);

            // –ø–æ–∫–∞–∑–∞—Ç—å –¥—É—ç–ª—å
            const myMove = (payload.p1.pid === PID ? payload.p1.move : payload.p2.pid === PID ? payload.p2.move : '');
            const oppMove = (payload.p1.pid !== PID ? payload.p1.move : payload.p2.move);
            el.youIcon.textContent = ICON[myMove];
            el.oppIcon.textContent = ICON[oppMove];
            // el.youIcon.textContent = myMove ? ICON[myMove] : '‚Äî';
            // el.oppIcon.textContent = oppMove ? ICON[oppMove] : '‚Äî';
            el.duel.style.display = 'block';

            // –≤—ã—Å—Ç–∞–≤–∏—Ç—å —Å—á—ë—Ç –ø–æ payload.score
            const myScore = Number(payload.score?.[PID] ?? 0);
            const oppKey = Object.keys(payload.score || {}).find(k => k !== PID);
            const oppScore = Number((oppKey && payload.score[oppKey]) ?? 0);
            stars(el.youScore, myScore);
            stars(el.oppScore, oppScore);

            // –±–∞–Ω–Ω–µ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
            if (!payload.winner) {
                text = `It's a draw`;
            } else if (payload.winner === PID) {
                text = `It's a win!`;
            } else {
                text = `You lost`;
            }
            el.message.textContent = text ? text : '';

            // –±–ª–æ–∫–∏—Ä—É–µ–º –ø–µ—Ä–µ—Ö–æ–¥ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —Å—Ç–µ–π—Ç—É
            state.resultLockUntil = now() + RESULT_GRACE_MS;

            // —á–µ—Ä–µ–∑ grace ‚Äî –ø—Ä–∏–º–µ–Ω–∏–º –æ—Ç–ª–æ–∂–µ–Ω–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ (–æ–±—ã—á–Ω–æ WAITING_MOVE)
            setTimeout(() => {
                if (state.deferred) {
                    const t = state.deferred.type; state.deferred = null;
                    if (t === 'WAITING_MOVE') onWaitingMove();
                }
            }, RESULT_GRACE_MS);
        }
        function onMatchOver() {
            if (now() < state.resultLockUntil) { state.deferred = { type: 'MATCH_OVER' }; setTimeout(() => onMatchOver(), state.resultLockUntil - now() + 5); return; }
            el.message.textContent = 'Match over';
            el.rematch.style.display = 'inline-block';
            setMoves(false);
        }

        // ====== Actions
        function sendMove(code) {
            if (!state.ws || state.ws.readyState !== 1) return;
            if (!state.canMove) return;
            state.canMove = false;
            state.ws.send(code);
            onAck();
        }
        function sendReady() {
            if (!state.ws || state.ws.readyState !== 1) return;
            state.ws.send('3'); // ClientEvent.READY
            el.rematch.style.display = 'none';
            el.message.textContent = 'Ready. Waiting for opponent‚Ä¶';
            setBanner('', '');
        }

        // ====== Bind UI
        document.querySelectorAll('[data-move]').forEach(btn => {
            btn.addEventListener('click', () => {
                const code = btn.getAttribute('data-move'); // r/p/s
                state.canMove = true; // —Ä–∞–∑—Ä–µ—à–∞–µ–º –æ–¥–∏–Ω –∫–ª–∏–∫
                sendMove(code);
                // –ª–æ–∫–∞–ª—å–Ω–æ –ø–æ–∫–∞–∂–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Ö–æ–¥
                el.duel.classList.remove("hidden");
                el.duel.style.display = 'block';
                el.youIcon.textContent = ICON[MOVES[code]];
            });
        });
        // el.rematch.addEventListener('click', sendReady);

        // ====== WS
        function connect() {
            // el.message.textContent = 'Connecting‚Ä¶'; setMoves(false); setBanner('', ''); el.duel.style.display = 'none';
            const ws = new WebSocket(wsURL());
            state.ws = ws;

            ws.onopen = () => {
                // el.message.textContent = 'Connected. Waiting for state‚Ä¶'; 
            };

            ws.onmessage = (ev) => {
                let msg; try { msg = JSON.parse(ev.data); } catch { return; }
                const { type, data } = msg;
                if (data && data.state) { updateFromSnapshot(data); }

                switch (type) {
                    case 'JOINED': onJoined(); break;
                    case 'WAITING_OPP': onWaitingOpp(); break;
                    case 'WAITING_MOVE': state.canMove = true; onWaitingMove(); break;
                    case 'ACK': onAck(); break;
                    case 'RESULT': onResult(data); break;
                    case 'MATCH_OVER':
                        if (now() < state.resultLockUntil) { state.deferred = { type: 'MATCH_OVER' }; }
                        else onMatchOver();
                        break;
                    case 'ERROR':
                        el.message.textContent = (data && data.message) || 'Error';
                        break;
                }
            };

            ws.onclose = () => { el.message.textContent = 'Disconnected'; setMoves(false); };
            ws.onerror = () => { el.message.textContent = 'WS error'; };
        }

        connect();
    </script>
</body>

</html>